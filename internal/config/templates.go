package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/otori-lab/otori-cli/internal/models"
)

// CowrieConfigTemplate is the template for cowrie.cfg
const CowrieConfigTemplate = `# Cowrie Configuration File
# Generated by Otori CLI
# Profile: %s

[honeypot]
hostname = %s
log_path = var/log/cowrie
download_path = var/lib/cowrie/downloads
contents_path = honeyfs
txtcmds_path = txtcmds
share_path = share/cowrie
state_path = var/lib/cowrie
etc_path = etc

[ssh]
enabled = true
listen_endpoints = tcp:2222:interface=0.0.0.0
version = SSH-2.0-OpenSSH_6.0p1 Debian-4+deb7u2

[telnet]
enabled = true
listen_endpoints = tcp:2223:interface=0.0.0.0

[output_jsonlog]
enabled = true
logfile = var/log/cowrie/cowrie.json

[output_textlog]
enabled = true
logfile = var/log/cowrie/cowrie.log
`

// UserDBTemplate is the default template for userdb.txt
const UserDBHeader = `# Cowrie User Database
# Generated by Otori CLI
# Format: username:uid:password
# Use * as wildcard, use ! to deny access
#
# Examples:
#   root:x:root       - Allow root with password "root"
#   admin:x:*         - Allow admin with any password
#   guest:x:!         - Deny all passwords for guest
#

`

// WriteCowrieConfig generates and writes cowrie.cfg for a profile
func WriteCowrieConfig(profileDir string, config *models.Config) error {
	content := fmt.Sprintf(CowrieConfigTemplate, config.ProfileName, config.ServerName)

	filename := filepath.Join(profileDir, "cowrie.cfg")
	if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing cowrie.cfg: %w", err)
	}

	return nil
}

// WriteUserDB generates and writes userdb.txt for a profile
func WriteUserDB(profileDir string, config *models.Config) error {
	var content strings.Builder
	content.WriteString(UserDBHeader)

	// Add users from config
	if len(config.Users) > 0 {
		for _, user := range config.Users {
			// Default: allow user with any password (wildcard)
			content.WriteString(fmt.Sprintf("%s:x:*\n", user))
		}
	} else {
		// Default users if none specified
		content.WriteString("root:x:*\n")
		content.WriteString("admin:x:*\n")
	}

	filename := filepath.Join(profileDir, "userdb.txt")
	if err := os.WriteFile(filename, []byte(content.String()), 0644); err != nil {
		return fmt.Errorf("error writing userdb.txt: %w", err)
	}

	return nil
}

// DockerComposeTemplate is the template for docker-compose.yml
const DockerComposeTemplate = `# Docker Compose for Cowrie Honeypot
# Generated by Otori CLI
# Profile: %s

services:
  cowrie:
    image: cowrie/cowrie:latest
    container_name: otori-%s
    restart: unless-stopped
    ports:
      - "2222:2222"   # SSH
      - "2223:2223"   # Telnet
    volumes:
      - ./cowrie.cfg:/cowrie/cowrie-git/etc/cowrie.cfg:ro
      - ./userdb.txt:/cowrie/cowrie-git/etc/userdb.txt:ro
      - ./honeyfs:/cowrie/cowrie-git/honeyfs:ro
      - cowrie-logs:/cowrie/cowrie-git/var/log/cowrie
      - cowrie-downloads:/cowrie/cowrie-git/var/lib/cowrie/downloads
    environment:
      - COWRIE_HOSTNAME=%s

volumes:
  cowrie-logs:
    name: otori-%s-logs
  cowrie-downloads:
    name: otori-%s-downloads
`

// WriteDockerCompose generates and writes docker-compose.yml for a profile
func WriteDockerCompose(profileDir string, config *models.Config) error {
	content := fmt.Sprintf(DockerComposeTemplate,
		config.ProfileName,
		config.ProfileName,
		config.ServerName,
		config.ProfileName,
		config.ProfileName,
	)

	filename := filepath.Join(profileDir, "docker-compose.yml")
	if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing docker-compose.yml: %w", err)
	}

	return nil
}

// PasswdTemplate contains the base system users for honeyfs /etc/passwd
const PasswdTemplate = `root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
sshd:x:101:65534::/var/run/sshd:/usr/sbin/nologin
`

// ShadowTemplate contains the base system users for honeyfs /etc/shadow
const ShadowTemplate = `root:$6$random$hash.placeholder.for.honeypot.root.user:15800:0:99999:7:::
daemon:*:15800:0:99999:7:::
bin:*:15800:0:99999:7:::
sys:*:15800:0:99999:7:::
sync:*:15800:0:99999:7:::
games:*:15800:0:99999:7:::
man:*:15800:0:99999:7:::
lp:*:15800:0:99999:7:::
mail:*:15800:0:99999:7:::
news:*:15800:0:99999:7:::
uucp:*:15800:0:99999:7:::
proxy:*:15800:0:99999:7:::
www-data:*:15800:0:99999:7:::
backup:*:15800:0:99999:7:::
list:*:15800:0:99999:7:::
irc:*:15800:0:99999:7:::
gnats:*:15800:0:99999:7:::
nobody:*:15800:0:99999:7:::
libuuid:!:15800:0:99999:7:::
sshd:*:15800:0:99999:7:::
`

// WriteHoneyFS generates the honeyfs directory structure with passwd and shadow
func WriteHoneyFS(profileDir string, config *models.Config) error {
	// Create honeyfs/etc directory
	etcDir := filepath.Join(profileDir, "honeyfs", "etc")
	if err := os.MkdirAll(etcDir, 0755); err != nil {
		return fmt.Errorf("error creating honeyfs/etc directory: %w", err)
	}

	// Generate passwd content
	var passwdContent strings.Builder
	passwdContent.WriteString(PasswdTemplate)

	// Add custom users from config (starting UID from 1000)
	uid := 1000
	users := config.Users
	if len(users) == 0 {
		users = []string{"root", "admin"}
	}
	for _, user := range users {
		if user != "root" { // root already in template
			passwdContent.WriteString(fmt.Sprintf("%s:x:%d:%d:%s:/home/%s:/bin/bash\n",
				user, uid, uid, strings.Title(user), user))
			uid++
		}
	}

	// Write passwd
	passwdPath := filepath.Join(etcDir, "passwd")
	if err := os.WriteFile(passwdPath, []byte(passwdContent.String()), 0644); err != nil {
		return fmt.Errorf("error writing honeyfs passwd: %w", err)
	}

	// Generate shadow content
	var shadowContent strings.Builder
	shadowContent.WriteString(ShadowTemplate)

	// Add custom users to shadow (with fake password hash)
	for _, user := range users {
		if user != "root" { // root already in template
			// Fake bcrypt-like hash for honeypot
			shadowContent.WriteString(fmt.Sprintf("%s:$6$xyz$fakehash.for.honeypot.user.%s:15800:0:99999:7:::\n",
				user, user))
		}
	}

	// Write shadow
	shadowPath := filepath.Join(etcDir, "shadow")
	if err := os.WriteFile(shadowPath, []byte(shadowContent.String()), 0644); err != nil {
		return fmt.Errorf("error writing honeyfs shadow: %w", err)
	}

	return nil
}
