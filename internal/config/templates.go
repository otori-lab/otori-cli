package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/otori-lab/otori-cli/internal/models"
)

// CowrieConfigTemplate is the template for cowrie.cfg
const CowrieConfigTemplate = `# Cowrie Configuration File
# Generated by Otori CLI
# Profile: %s

[honeypot]
hostname = %s
log_path = var/log/cowrie
download_path = var/lib/cowrie/downloads
contents_path = honeyfs
txtcmds_path = txtcmds
share_path = share/cowrie
state_path = var/lib/cowrie
etc_path = etc

[ssh]
enabled = true
listen_endpoints = tcp:2222:interface=0.0.0.0
version = SSH-2.0-OpenSSH_6.0p1 Debian-4+deb7u2

[telnet]
enabled = true
listen_endpoints = tcp:2223:interface=0.0.0.0

[output_jsonlog]
enabled = true
logfile = var/log/cowrie/cowrie.json

[output_textlog]
enabled = true
logfile = var/log/cowrie/cowrie.log
`

// UserDBTemplate is the default template for userdb.txt
const UserDBHeader = `# Cowrie User Database
# Generated by Otori CLI
# Format: username:uid:password
# Use * as wildcard, use ! to deny access
#
# Examples:
#   root:x:root       - Allow root with password "root"
#   admin:x:*         - Allow admin with any password
#   guest:x:!         - Deny all passwords for guest
#

`

// WriteCowrieConfig generates and writes cowrie.cfg for a profile
func WriteCowrieConfig(profileDir string, config *models.Config) error {
	content := fmt.Sprintf(CowrieConfigTemplate, config.ProfileName, config.ServerName)

	filename := filepath.Join(profileDir, "cowrie.cfg")
	if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing cowrie.cfg: %w", err)
	}

	return nil
}

// WriteUserDB generates and writes userdb.txt for a profile
func WriteUserDB(profileDir string, config *models.Config) error {
	var content strings.Builder
	content.WriteString(UserDBHeader)

	// Add users from config
	if len(config.Users) > 0 {
		for _, user := range config.Users {
			// Default: allow user with any password (wildcard)
			content.WriteString(fmt.Sprintf("%s:x:*\n", user))
		}
	} else {
		// Default users if none specified
		content.WriteString("root:x:*\n")
		content.WriteString("admin:x:*\n")
	}

	filename := filepath.Join(profileDir, "userdb.txt")
	if err := os.WriteFile(filename, []byte(content.String()), 0644); err != nil {
		return fmt.Errorf("error writing userdb.txt: %w", err)
	}

	return nil
}

// DockerComposeTemplate is the template for docker-compose.yml
const DockerComposeTemplate = `# Docker Compose for Cowrie Honeypot
# Generated by Otori CLI
# Profile: %s

services:
  cowrie:
    image: cowrie/cowrie:latest
    container_name: otori-%s
    restart: unless-stopped
    ports:
      - "2222:2222"   # SSH
      - "2223:2223"   # Telnet
    volumes:
      - ./cowrie.cfg:/cowrie/cowrie-git/etc/cowrie.cfg:ro
      - ./userdb.txt:/cowrie/cowrie-git/etc/userdb.txt:ro
      - ./honeyfs:/cowrie/cowrie-git/honeyfs:ro
      - cowrie-logs:/cowrie/cowrie-git/var/log/cowrie
      - cowrie-downloads:/cowrie/cowrie-git/var/lib/cowrie/downloads
    environment:
      - COWRIE_HOSTNAME=%s

volumes:
  cowrie-logs:
    name: otori-%s-logs
  cowrie-downloads:
    name: otori-%s-downloads
`

// WriteDockerCompose generates and writes docker-compose.yml for a profile
func WriteDockerCompose(profileDir string, config *models.Config) error {
	content := fmt.Sprintf(DockerComposeTemplate,
		config.ProfileName,
		config.ProfileName,
		config.ServerName,
		config.ProfileName,
		config.ProfileName,
	)

	filename := filepath.Join(profileDir, "docker-compose.yml")
	if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing docker-compose.yml: %w", err)
	}

	return nil
}

// GetOtoriDir returns the otori config directory (~/.otori)
func GetOtoriDir() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return ".otori"
	}
	return filepath.Join(homeDir, ".otori")
}

// GetBaseHoneyFSDir returns the base honeyfs directory (~/.otori/cowrie-honeyfs-base)
func GetBaseHoneyFSDir() string {
	return filepath.Join(GetOtoriDir(), "cowrie-honeyfs-base")
}

// WriteHoneyFS copies the base honeyfs and adds custom users
func WriteHoneyFS(profileDir string, config *models.Config) error {
	honeyfsDir := filepath.Join(profileDir, "honeyfs")
	baseHoneyFS := GetBaseHoneyFSDir()

	// Check if base honeyfs exists
	if _, err := os.Stat(baseHoneyFS); os.IsNotExist(err) {
		return fmt.Errorf("base honeyfs not found at %s (run 'make install' first)", baseHoneyFS)
	}

	// Copy base honeyfs to profile
	if err := copyDir(baseHoneyFS, honeyfsDir); err != nil {
		return fmt.Errorf("error copying base honeyfs: %w", err)
	}

	// Add custom users to passwd and shadow
	users := config.Users
	if len(users) == 0 {
		users = []string{"root", "admin"}
	}

	// Append custom users to passwd
	passwdPath := filepath.Join(honeyfsDir, "etc", "passwd")
	if err := appendUsersToPasswd(passwdPath, users); err != nil {
		return fmt.Errorf("error updating passwd: %w", err)
	}

	// Append custom users to shadow
	shadowPath := filepath.Join(honeyfsDir, "etc", "shadow")
	if err := appendUsersToShadow(shadowPath, users); err != nil {
		return fmt.Errorf("error updating shadow: %w", err)
	}

	// Append custom users to group
	groupPath := filepath.Join(honeyfsDir, "etc", "group")
	if err := appendUsersToGroup(groupPath, users); err != nil {
		return fmt.Errorf("error updating group: %w", err)
	}

	// Update hostname
	hostnamePath := filepath.Join(honeyfsDir, "etc", "hostname")
	hostname := config.ServerName
	if hostname == "" {
		hostname = "svr04"
	}
	if err := os.WriteFile(hostnamePath, []byte(hostname+"\n"), 0644); err != nil {
		return fmt.Errorf("error updating hostname: %w", err)
	}

	// Create custom bait file
	shareDir := filepath.Join(honeyfsDir, "etc", "share")
	if err := os.MkdirAll(shareDir, 0755); err != nil {
		return fmt.Errorf("error creating share directory: %w", err)
	}
	secretContent := `# Confidential - Do Not Share
DB_HOST=192.168.1.100
DB_USER=admin
DB_PASS=SuperSecret123!
`
	if err := os.WriteFile(filepath.Join(shareDir, "secret.txt"), []byte(secretContent), 0644); err != nil {
		return fmt.Errorf("error writing secret.txt: %w", err)
	}

	return nil
}

// copyDir recursively copies a directory
func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Get relative path
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		// Copy file
		data, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		return os.WriteFile(dstPath, data, info.Mode())
	})
}

// appendUsersToPasswd adds custom users to passwd file
func appendUsersToPasswd(path string, users []string) error {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	uid := 1000
	for _, user := range users {
		if user != "root" {
			line := fmt.Sprintf("%s:x:%d:%d:%s:/home/%s:/bin/bash\n",
				user, uid, uid, capitalize(user), user)
			if _, err := f.WriteString(line); err != nil {
				return err
			}
			uid++
		}
	}
	return nil
}

// appendUsersToShadow adds custom users to shadow file
func appendUsersToShadow(path string, users []string) error {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	for _, user := range users {
		if user != "root" {
			line := fmt.Sprintf("%s:*:15800:0:99999:7:::\n", user)
			if _, err := f.WriteString(line); err != nil {
				return err
			}
		}
	}
	return nil
}

// appendUsersToGroup adds custom user groups to group file
func appendUsersToGroup(path string, users []string) error {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	gid := 1000
	for _, user := range users {
		if user != "root" {
			line := fmt.Sprintf("%s:x:%d:\n", user, gid)
			if _, err := f.WriteString(line); err != nil {
				return err
			}
			gid++
		}
	}
	return nil
}

// capitalize returns the string with first letter capitalized
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
